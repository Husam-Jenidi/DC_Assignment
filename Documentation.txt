Q:  What does "__init__" method do?
A:  The `__init__` method is used to set the initial state of an object when it is created from a class. It is used to define and
    initialize the attributes of the class, and to set them to some initial value.
    It's important to note that the `__init__` method is called automatically when an object is created from the class,
    so no need to call it explicitly.

Q: Abstract of the System
A:  This is a simple event simulator that uses a priority queue (implemented using the heapq library) to manage events.
    The EventQueue class defines the priority queue and has methods for adding and removing events, as well as checking if
    the queue is empty.
    The Simulation class represents the simulation state, with a simulated time (self.t) and an event queue
    (self.events).
     The schedule method is used to schedule events to occur after a certain delay, and the run method runs the
    simulation by processing events from the queue until the queue is empty or the maximum simulated time (max_t) is reached.
    The Event class represents an event and has a process method that is called when the event is processed by the simulation.
    Subclasses of Event can be created to represent specific types of events, and can define their own initialization method
    and process method to customize their behavior.
    Overall, this code is implementation of a simple event simulator.

Q: Explanation of each class and its functions in the code we worked on:
A:
    This is a simulation code that uses classes and functions to model an event queue system. Since this code is written in python we will make use of the
    libraries heapq and logging. The heapq library is used to implement the queueing system while the logging library is used to log events that occur during
    the simulation.

    The code consists of 4 classes:

 (EventQueue): This class is responsible for creating and managing the event queue. It has 4 methods which are:
  "push" which is used to add events to the queue,
  "pop" which is used to remove events from the queue,
  "is_empty" which is used to check if the queue is empty
  "print_events" which is used to print the events in the queue. I added this function for testing needs, it's not necessary

 (Simulation): This class is responsible for simulating the event queue system. It has 3 methods which are:
 "schedule" which is used to schedule an event to occur after a certain delay,
 "run" which is used to run the simulation,
 "log_info" which is used to log messages with the level of "info" and the current simulated time.

 (Event): This class is responsible for representing the events in the simulation. It has 4 attributes that are {name, duration, callback and priority}.
  And it has one method "process" which is used to process the event and schedule the end event.

 *optional *EndEvent: This class is responsible for representing the end event of each event. It has the same attributes as the Event class, but it has a different
  process method which is used to log the end of the event.


at the end of the code, the function my_callback is defined, then an instance of the Simulation class is created and an instance of the Event class is created
and scheduled to occur after 5 seconds using the schedule method of the Simulation class. The simulation is then run and the events in the queue are printed
 using the print_events method of the EventQueue class.

Q: the Run method in the Class Simulation
A: This is the run method of the Simulation class. The method is used to run the simulation. The method takes one optional argument max_t,
   which represents the maximum time that the simulation should run for. If max_t is not specified, it defaults to infinity (float('inf'))
   which means that the simulation will run until the event queue is empty.
   The method runs in a loop as long as the event queue is not empty. The loop starts by retrieving the next event in the queue using the
   pop method of the EventQueue class. It then checks if the current simulation time self.t is greater than the maximum time max_t, if so
   it breaks the loop.
   It then updates the simulation time self.t to be the priority of the event that was just retrieved. The priority is the time that the
   event should occur.
   Finally, it calls the process method of the event. This method is implemented in the Event class and is used to process the event and
   perform any necessary actions. The self argument is passed as a parameter which refers to the current instance of the Simulation class,
   so the Event class can access the simulation state.

Q: The output explain
{ INFO:root:5.00: Started Event 1
  INFO:root:10.00: Ended Event 1
  Event finished }
A: The output shows that the event simulator is working as expected. The first line of the output, "Event finished", is printed by
the "my_callback function", which was passed as the callback for the event. This indicates that the callback was called when the
event was processed.
The next two lines of the output are log messages that were generated by the log_info function in the Simulation class.
The first log message, "INFO:root:5.00: Started Event 1", indicates that the event named "Event 1" has started at time 5.00S.
The second log message, "INFO:root:10.00: Ended Event 1", indicates that the event named "Event 1" has ended at time 10.00S.
It's worth noting that the time at which the event ends is 5 seconds after the time at which the event starts, as specified by
the schedule function which adds the event to the event queue with a delay of 5 seconds.
The log message is printed by the log_info function in the Simulation class, which takes the current simulated time
(stored in the self.t variable) and the message passed as an argument, and formats them into a string that is passed to the
logging.info function. The logging.info function is part of the logging module, which you configured at the beginning of the
script with `logging.basicConfig(level=logging.
