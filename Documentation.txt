
            Discrete event simulation

Q:  What does "__init__" method do?
A:  The `__init__` method is used to set the initial state of an object when it is created from a class. It is used to define and
    initialize the attributes of the class, and to set them to some initial value.
    It's important to note that the `__init__` method is called automatically when an object is created from the class,
    so no need to call it explicitly.

Q: Abstract of the System
A:  This is a simple event simulator that uses a priority queue (implemented using the heapq library) to manage events.
    The EventQueue class defines the priority queue and has methods for adding and removing events, as well as checking if
    the queue is empty.
    The Simulation class represents the simulation state, with a simulated time (self.t) and an event queue
    (self.events).
     The schedule method is used to schedule events to occur after a certain delay, and the run method runs the
    simulation by processing events from the queue until the queue is empty or the maximum simulated time (max_t) is reached.
    The Event class represents an event and has a process method that is called when the event is processed by the simulation.
    Subclasses of Event can be created to represent specific types of events, and can define their own initialization method
    and process method to customize their behavior.
    Overall, this code is implementation of a simple event simulator.

Q: Explanation of each class and its functions in the code we worked on:
A:
    This is a simulation code that uses classes and functions to model an event queue system. Since this code is written in python we will make use of the
    libraries heapq and logging. The heapq library is used to implement the queueing system while the logging library is used to log events that occur during
    the simulation.

    The code consists of 4 classes:

 (EventQueue): This class is responsible for creating and managing the event queue. It has 4 methods which are:
  "push" which is used to add events to the queue,
  "pop" which is used to remove events from the queue,
  "is_empty" which is used to check if the queue is empty
  "print_events" which is used to print the events in the queue. I added this function for testing needs, it's not necessary

 (Simulation): This class is responsible for simulating the event queue system. It has 3 methods which are:
 "schedule" which is used to schedule an event to occur after a certain delay,
 "run" which is used to run the simulation,
 "log_info" which is used to log messages with the level of "info" and the current simulated time.

 (Event): This class is responsible for representing the events in the simulation. It has 4 attributes that are {name, duration, callback and priority}.
  And it has one method "process" which is used to process the event and schedule the end event.

 *optional *EndEvent: This class is responsible for representing the end event of each event. It has the same attributes as the Event class, but it has a different
  process method which is used to log the end of the event.


at the end of the code, the function my_callback is defined, then an instance of the Simulation class is created and an instance of the Event class is created
and scheduled to occur after 5 seconds using the schedule method of the Simulation class. The simulation is then run and the events in the queue are printed
 using the print_events method of the EventQueue class.

Q: the Run method in the Class Simulation
A: This is the run method of the Simulation class. The method is used to run the simulation. The method takes one optional argument max_t,
   which represents the maximum time that the simulation should run for. If max_t is not specified, it defaults to infinity (float('inf'))
   which means that the simulation will run until the event queue is empty.
   The method runs in a loop as long as the event queue is not empty. The loop starts by retrieving the next event in the queue using the
   pop method of the EventQueue class. It then checks if the current simulation time self.t is greater than the maximum time max_t, if so
   it breaks the loop.
   It then updates the simulation time self.t to be the priority of the event that was just retrieved. The priority is the time that the
   event should occur.
   Finally, it calls the process method of the event. This method is implemented in the Event class and is used to process the event and
   perform any necessary actions. The self argument is passed as a parameter which refers to the current instance of the Simulation class,
   so the Event class can access the simulation state.

Q: The output explain
{ INFO:root:5.00: Started Event 1
  INFO:root:10.00: Ended Event 1
  Event finished }
A: The output shows that the event simulator is working as expected. The first line of the output, "Event finished", is printed by
the "my_callback function", which was passed as the callback for the event. This indicates that the callback was called when the
event was processed.
The next two lines of the output are log messages that were generated by the log_info function in the Simulation class.
The first log message, "INFO:root:5.00: Started Event 1", indicates that the event named "Event 1" has started at time 5.00S.
The second log message, "INFO:root:10.00: Ended Event 1", indicates that the event named "Event 1" has ended at time 10.00S.
It's worth noting that the time at which the event ends is 5 seconds after the time at which the event starts, as specified by
the schedule function which adds the event to the event queue with a delay of 5 seconds.
The log message is printed by the log_info function in the Simulation class, which takes the current simulated time
(stored in the self.t variable) and the message passed as an argument, and formats them into a string that is passed to the
logging.info function. The logging.info function is part of the logging module, which you configured at the beginning of the
script with `logging.basicConfig(level=logging.


        MMN_queue
the explanation of the first class MMN(simulation)

The previous class is for a single queue Multi-Server Multi-Queue (MMN) system.
The class inherits from the Simulation class, which provides basic functionalities for running a discrete event simulation, such as
 scheduling events and keeping track of the simulated time.
The __init__ method initializes the state of the simulation. It takes three parameters: lambd which is the arrival rate of jobs, mu which
 is the service rate of the servers, and n which is the number of servers in the system. The n parameter is not used in this implementation
  as it is designed to only work for a single queue. If n is not equal to 1, it raises a NotImplementedError. The method also calls the
   __init__ method of the Simulation class using super().__init__()

The class has several instance variables:

running: to keep track of the job that is currently being serviced, it's initial value is None.
queue: is a FIFO queue for the system, implemented as a Python deque.
arrivals: dictionary that maps job ids to their arrival times.
completions: dictionary that maps job ids to their completion times.
lambd: arrival rate of jobs
mu: service rate of servers
n: number of servers in the system
arrival_rate: the arrival rate of the jobs divided by the number of servers
completion_rate: the service rate of the servers divided by the number of servers
The class has three methods:

schedule_arrival(self, job_id): schedules the arrival of a new job following an exponential distribution, to compensate the number of
 queues the arrival time should depend also on "n"
schedule_completion(self, job_id): schedules the time of the completion event of a job following an exponential distribution, to compensate
 the number of servers the completion time should depend also on "n"
queue_len: is a property that returns the current number of jobs in the system, which is the length of the queue plus 1 if a job is
currently being serviced.
The class also schedules the first arrival event at time 0, with self.schedule(expovariate(lambd), Arrival(0))

It's important to notice that the class is incomplete and some methods are missing their implementation and some variables are not being used.