
            Discrete event simulation

Q:  What does "__init__" method do?
A:  The `__init__` method is used to set the initial state of an object when it is created from a class. It is used to define and
    initialize the attributes of the class, and to set them to some initial value.
    It's important to note that the `__init__` method is called automatically when an object is created from the class,
    so no need to call it explicitly.

Q: Abstract of the System
A:  This is a simple event simulator that uses a priority queue (implemented using the heapq library) to manage events.
    The EventQueue class defines the priority queue and has methods for adding and removing events, as well as checking if
    the queue is empty.
    The Simulation class represents the simulation state, with a simulated time (self.t) and an event queue
    (self.events).
     The schedule method is used to schedule events to occur after a certain delay, and the run method runs the
    simulation by processing events from the queue until the queue is empty or the maximum simulated time (max_t) is reached.
    The Event class represents an event and has a process method that is called when the event is processed by the simulation.
    Subclasses of Event can be created to represent specific types of events, and can define their own initialization method
    and process method to customize their behavior.
    Overall, this code is implementation of a simple event simulator.

Q: Explanation of each class and its functions in the code we worked on:
A:
    This is a simulation code that uses classes and functions to model an event queue system. Since this code is written in python we will make use of the
    libraries heapq and logging. The heapq library is used to implement the queueing system while the logging library is used to log events that occur during
    the simulation.

    The code consists of 4 classes:

 (EventQueue): This class is responsible for creating and managing the event queue. It has 4 methods which are:
  "push" which is used to add events to the queue,
  "pop" which is used to remove events from the queue,
  "is_empty" which is used to check if the queue is empty
  "print_events" which is used to print the events in the queue. I added this function for testing needs, it's not necessary

 (Simulation): This class is responsible for simulating the event queue system. It has 3 methods which are:
 "schedule" which is used to schedule an event to occur after a certain delay,
 "run" which is used to run the simulation,
 "log_info" which is used to log messages with the level of "info" and the current simulated time.

 (Event): This class is responsible for representing the events in the simulation. It has 4 attributes that are {name, duration, callback and priority}.
  And it has one method "process" which is used to process the event and schedule the end event.

 *optional *EndEvent: This class is responsible for representing the end event of each event. It has the same attributes as the Event class, but it has a different
  process method which is used to log the end of the event.


at the end of the code, the function my_callback is defined, then an instance of the Simulation class is created and an instance of the Event class is created
and scheduled to occur after 5 seconds using the schedule method of the Simulation class. The simulation is then run and the events in the queue are printed
 using the print_events method of the EventQueue class.

Q: the Run method in the Class Simulation
A: This is the run method of the Simulation class. The method is used to run the simulation. The method takes one optional argument max_t,
   which represents the maximum time that the simulation should run for. If max_t is not specified, it defaults to infinity (float('inf'))
   which means that the simulation will run until the event queue is empty.
   The method runs in a loop as long as the event queue is not empty. The loop starts by retrieving the next event in the queue using the
   pop method of the EventQueue class. It then checks if the current simulation time self.t is greater than the maximum time max_t, if so
   it breaks the loop.
   It then updates the simulation time self.t to be the priority of the event that was just retrieved. The priority is the time that the
   event should occur.
   Finally, it calls the process method of the event. This method is implemented in the Event class and is used to process the event and
   perform any necessary actions. The self argument is passed as a parameter which refers to the current instance of the Simulation class,
   so the Event class can access the simulation state.

Q: The output explain
{ INFO:root:5.00: Started Event 1
  INFO:root:10.00: Ended Event 1
  Event finished }
A: The output shows that the event simulator is working as expected. The first line of the output, "Event finished", is printed by
the "my_callback function", which was passed as the callback for the event. This indicates that the callback was called when the
event was processed.
The next two lines of the output are log messages that were generated by the log_info function in the Simulation class.
The first log message, "INFO:root:5.00: Started Event 1", indicates that the event named "Event 1" has started at time 5.00S.
The second log message, "INFO:root:10.00: Ended Event 1", indicates that the event named "Event 1" has ended at time 10.00S.
It's worth noting that the time at which the event ends is 5 seconds after the time at which the event starts, as specified by
the schedule function which adds the event to the event queue with a delay of 5 seconds.
The log message is printed by the log_info function in the Simulation class, which takes the current simulated time
(stored in the self.t variable) and the message passed as an argument, and formats them into a string that is passed to the
logging.info function. The logging.info function is part of the logging module, which you configured at the beginning of the
script with `logging.basicConfig(level=logging.


        MMN_queue
the explanation of the first class MMN(simulation)

The previous class is for a single queue Multi-Server Multi-Queue (MMN) system.
The class inherits from the Simulation class, which provides basic functionalities for running a discrete event simulation, such as
scheduling events and keeping track of the simulated time.
The __init__ method initializes the state of the simulation. It takes three parameters: lambd which is the arrival rate of jobs, mu which
is the service rate of the servers, and n which is the number of servers in the system. The n parameter is not used in this implementation
as it is designed to only work for a single queue. If n is not equal to 1, it raises a NotImplementedError.
The method also calls the __init__ method of the Simulation class using super().__init__()

The class has several instance variables:
running: to keep track of the job that is currently being serviced, it's initial value is None.
queue: is a FIFO queue for the system, implemented as a Python deque.
arrivals: dictionary that maps job ids to their arrival times.
completions: dictionary that maps job ids to their completion times.
lambd: arrival rate of jobs
mu: service rate of servers
n: number of servers in the system
arrival_rate: the arrival rate of the jobs divided by the number of servers
completion_rate: the service rate of the servers divided by the number of servers

The class has three methods:
schedule_arrival(self, job_id): schedules the arrival of a new job following an exponential distribution, to compensate the number of queues
the arrival time should depend also on "n"
schedule_completion(self, job_id): schedules the time of the completion event of a job following an exponential distribution, to compensate
the number of servers the completion time should depend also on "n"
queue_len: is a property that returns the current number of jobs in the system, which is the length of the queue plus 1 if a job is currently
being serviced.
The class also schedules the first arrival event at time 0, with self.schedule(expovariate(lambd), Arrival(0))
It's important to notice that the class is incomplete and some methods are missing their implementation and some variables are not being used.


The explanation of the Second class Arrival(Event)

The class "Arrival" is a subclass of the built-in Python class "Event", which means that it inherits all of the properties and methods of
the "Event" class.
The class has an init method that takes in a single argument "job_id" which is used to initialize the "id" attribute of the class.
The class also has a "process" method which takes in a single argument "sim" of type "MMN". This method is used to handle the processing
logic when an arrival event occurs in the simulation.
The process method starts by setting the arrival time of the job using the current simulation time.
Then, it checks if there is no running job, if this is the case it assigns the incoming job to the running job and schedules its completion
time by calling the schedule_completion method on the simulation object.
Otherwise, if there is already a running job, it puts the incoming job into the queue.
Finally, it schedules the arrival of the next job by calling the schedule_arrival method on the simulation object.
The Arrival class is used to track the arrival of new jobs to the MMN Queue system, it uses the "job_id" attribute to keep track of the job,
and the process method is used to handle the event of arrival and do the needed actions according to the current state of the system.

""The explanation of the Third class Completion(Event)""

In this class, we create an instance of the class Completion, that represents the event of a job being completed. In the constructor,
we take a job_id as a parameter. The job_id is not used in this class.
The process() method is called when the completion event occurs. The method takes an instance of the MMN class as a parameter. In this
method, we first assert that there is a running job(sim.running should not be None). This is because the completion event should not be
scheduled if there is no running job.
Then we set the completion time of the running job by adding the current simulated time sim.t to the dictionary sim.completions with the
key of the running job.
Then, we check if the queue is not empty. If it is not, we get the next job from the queue using the popleft() method of the deque class.
This method removes the leftmost element of the deque, which is the next job in the queue. Then we set the running job to this next job,
and schedule its completion by calling the schedule_completion() method of the MMN class with the next job as a parameter.
If the queue is empty, we set the running job to None, which indicates that there are no jobs running in the system.

The full explanation of the code

This code is a simulation of a Multi-Server Multi-Queue (MMN) system, which is a generalization of the M/M/1 queue system to multiple servers
and multiple queues. The simulation is implemented using the discrete event simulation (DES) technique.
The MMN class inherits from the Simulation class, which is a general class for running discrete event simulations. The MMN class has several
instance variables. The running variable is set to None if there is no running job. If a job is running, the variable is set to the id of the
running job. The queue variable is a FIFO queue to store jobs that are waiting to be serviced. The arrivals and completions variables are
dictionaries that map the job id to its arrival and completion times respectively.

The lambd,mu,n are the overall arrival rate for the system, service rate, and number of servers in the system. The arrival_rate and
completion_rate are computed by dividing the lambd and mu by the number of servers (n).
The schedule_arrival method schedules the arrival of a job following an exponential distribution. The schedule_completion method schedules
the time of the completion event. The queue_len property returns the length of the queue.
The Arrival class is an event representing the arrival of a job in the system. When the process method is called, it records the arrival
time of the job in the arrivals dictionary, assigns the incoming job to running if there is no running job, schedules its completion,
otherwise it puts the job into the queue and schedules the arrival of the next job.

The Completion class is an event representing the completion of a job. When the process method is called, it records the completion time
of the running job in the completions dictionary, schedules the completion of the next job from the queue if the queue is not empty,
otherwise it sets the running job to None.

In the main function, the simulation is created with the values of lambd, mu, n, max-t passed as command-line arguments. The simulation is
then run and the results are stored in a CSV file if the --csv option is provided.