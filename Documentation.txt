Q: Abstract of the System
A: This is a simple event simulator that uses a priority queue (implemented using the heapq library) to manage events.
The EventQueue class defines the priority queue and has methods for adding and removing events, as well as checking if
the queue is empty. The Simulation class represents the simulation state, with a simulated time (self.t) and an event queue
(self.events). The schedule method is used to schedule events to occur after a certain delay, and the run method runs the
simulation by processing events from the queue until the queue is empty or the maximum simulated time (max_t) is reached.
The Event class represents an event and has a process method that is called when the event is processed by the simulation.
Subclasses of Event can be created to represent specific types of events, and can define their own initialization method
 and process method to customize their behavior. Overall, this code is a great starting point for a simple event simulator,
 but it's missing some important features like handling the event queue, it seems to be missing the EventQueue class, also
 the callback function is not defined which is called inside the process method.

Q: Brief explanation of each class and its functions in the code we worked on:
A:
    EventQueue: This class defines a basic priority queue that is used to hold the events scheduled by the simulation. It has
     three functions:

    push(event, priority): This function adds an event to the queue with a specified priority. The event is added to the queue
     using the heapq.heappush function, which is a built-in python function that allows for efficient implementation of a priority queue.
    pop(): This function removes the event with the highest priority from the queue and returns it. It uses the heapq.heappop
     function to implement this.
    is_empty(): This function returns True if the queue is empty and False otherwise.

    Simulation: This class represents the state of the simulation, and it has several functions:

        __init__(): This function initializes the simulation. It sets the simulated time to zero and creates an empty event queue.
        schedule(delay, event): This function schedules an event to occur after a specified delay. It adds the event to the event
        queue with a priority equal to the current simulated time plus the delay.
        run(max_t=float('inf')): This function runs the simulation. It repeatedly takes the next event from the event queue
        (the one with the highest priority) and processes it. It stops when the event queue is empty or when the simulated time
        is greater than max_t.
        log_info(msg): This function logs the message passed as an argument and the current simulated time.

    Event: This is an abstract class that represents an event. It has three functions:

        __init__(name, duration, callback): This function initializes an event with a name, duration and a callback function.
        process(sim1): This function processes the event. It logs that the event has started, schedules an EndEvent to occur
        after the event's duration, and then calls the event's callback function.
        priority: This variable holds the priority of the event, which is used to order the events in the event queue.

    EndEvent: This class is used to represent the end of an event. It has one function:

        process(sim1): This function logs that the event has ended.

    It's worth noting that the my_callback function is an example of a callback function that is passed to an event.
    It is called when the event is processed, in this example it just print "Event finished" but it could have any other
    functionality.


Q: The output explain
{ INFO:root:5.00: Started Event 1
  INFO:root:10.00: Ended Event 1
  Event finished }
A: The output shows that the event simulator is working as expected. The first line of the output, "Event finished", is printed by
the my_callback function, which was passed as the callback for the event. This indicates that the callback was called when the
event was processed.
The next two lines of the output are log messages that were generated by the log_info function in the Simulation class.
The first log message, "INFO:root:5.00: Started Event 1", indicates that the event named "Event 1" has started at time 5.00S.
The second log message, "INFO:root:10.00: Ended Event 1", indicates that the event named "Event 1" has ended at time 10.00S.
It's worth noting that the time at which the event ends is 5 seconds after the time at which the event starts, as specified by
the schedule function which adds the event to the event queue with a delay of 5 seconds.
The log message is printed by the log_info function in the Simulation class, which takes the current simulated time
(stored in the self.t variable) and the message passed as an argument, and formats them into a string that is passed to the
logging.info function. The logging.info function is part of the logging module, which you configured at the beginning of the
script with `logging.basicConfig(level=logging.